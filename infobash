#!/bin/bash
# InfoBash, the universal, portable, system info script for irc.
# tested with ircII,irssi,bitchX,xchat,ksirc,konversation,weechat
# Copyright (C) 2005  locsmif <infobash@rebelhomicide.demon.nl>

# Freenode:
# Many thanks to etorix, Kano, kelmo, slh in alphabetical order 
# and #kanotix for their suggestions and betatesting
# Thanks to friends from #bash for their deep insight, as always.

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

#   DEPENDENCIES
# bash >=2.05b(bash), tr;readlink;uname;df;wc(coreutils), wget(wget), 
# hostname(hostname), free;ps;uptime(procps), lspci(pciutils), bc(bc)
# xrandr;xdpyinfo;glxinfo(xbase-clients), grep(grep), gawk(gawk)
# Also the proc filesystem should be present and mounted

exec 2>/dev/null # Reroute all error messages to the bitbucket
DEBUG=0
((DEBUG)) && exec 2>&1 # This is for debugging konversation

#################################################################################
#######################  UNCALCULATED VARIABLES  ################################
#################################################################################

MYVERSION="Infobash v2.50rc21"
LC_ALL="C"	# Make sure every program speaks English.
export LC_ALL 
OIFS="$IFS"	# Backup the current Internal Field Seperator
TIMEOUT="6"	# The timeout value in seconds for --update. You should override this in the rc-files if you experience problems.
# COLORS
#         DGREY    BLACK    RED      DRED     GREEN    DGREEN   YELLOW   DYELLOW
ANSICL="[1;30m [0;30m [1;31m [0;31m [1;32m [0;32m [1;33m [0;33m"
IRCCL="   \x0314   \x0301   \x0304   \x0305   \x0309   \x0303   \x0308   \x0307"
#                 BLUE     DBLUE    MAGENTA  DMAGENTA CYAN     DCYAN    WHITE    GREY     NORMAL
ANSICL="$ANSICL [1;34m [0;34m [1;35m [0;35m [1;36m [0;36m [1;37m [0;37m [0;37m"
IRCCL=" $IRCCL    \x0312   \x0302   \x0313   \x0306   \x0311   \x0310   \x0300   \x0315   \x03"
#ANSICL=($ANSICL); IRCCL=($IRCCL)
COLORS=(DGREY BLACK RED DRED GREEN DGREEN YELLOW DYELLOW BLUE DBLUE MAGENTA DMAGENTA CYAN DCYAN WHITE GREY NORMAL)
SCHEMES=(-- NORMAL,NORMAL,NORMAL BLUE,NORMAL,NORMAL GREEN,YELLOW,NORMAL DYELLOW,NORMAL,NORMAL CYAN,BLUE,NORMAL RED,NORMAL,NORMAL GREEN,NORMAL,NORMAL YELLOW,NORMAL,NORMAL GREEN,DGREEN,NORMAL BLUE,RED,NORMAL BLUE,NORMAL,RED YELLOW,WHITE,GREEN BLUE,NORMAL,GREEN DCYAN,NORMAL,DMAGENTA)
DEFSCHEME=2	# Defaults to 2, make this 1 for no colors. Set to any other valid scheme if you like. (Same number as when you run it) 
SHOWHOST=1	# Set this to 0 to avoid printing the hostname 
SHOWIRC=2	# SHOWIRC=1 to avoid showing the irc client version number, or SHOWIRC=0 to disable client information completely.
INDENT=14	# Default indentation level
VBL=0		# Verbosity level defaults to 0, this can also be set with -v, -v2, -v3, etc as a parameter.
IBSHELL=0	# Running in a shell? Defaults to false, and is determined later.
NOCPUCOUNT=0	# Wether or not the string "dual" or similar is found in cpuinfo output. If so, avoid dups.
#DISTROS="kanotix-version knoppix-version debian_version mandrake-release SuSE-release turbolinux-release slackware-release gentoo_release"
#DISTROS="$DISTROS redhat-release issue" # Make sure that "issue" is last!
FL1='-'		# These two determine seperators in single line output, to force irc clients not to break off sections
FL2=''
# Precede a banword with $'\2' to prevent it from being subject to automated escaping by the mkbans routine
# $'\1' gets weird results :
# user@host $ ARR=($'\x01'"one two" three four); echo ${ARR[0]} | hd -v
# 00000000  01 01 6f 6e 65 20 74 77  6f 0a                    |..one two.|
NORMALBANS=(corporation communications technologies technology group $'\2'"\<ltd\>" ltd. $'\2'"\<inc\>" inc. $'\2'\<co\> co. "(tm)" "(r)" $'\2'"\(rev ..\)")
CPUBANS=(cpu processor $'\2'"[0-9.]+ *[MmGg][Hh][Zz]")
XPATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin" # Extra path variable to make execute failures less likely, merged below
PARAMLIMIT=30	# This is a variable that controls how many parameters infobash will parse in a /proc/<pid>/cmdline file before stopping.
CRAP=0		# New parameter
FLAG=0		# A throw-away 'flag' variable intended to be used throughout infobash
KONVICFG="konversation/scripts/infobash.conf" # relative path to $(kde-config --path data)
DCOPOBJ="default"

[[ -s /etc/infobash.conf ]] && source /etc/infobash.conf	# Source global config overrides
[[ -s $HOME/.infobash ]] && source $HOME/.infobash 		# Source user config overrides
# WARNING: In the main part below (search for 'KONVI') 
# there's a check for Konversation-specific config files.
# Any one of these can override the above if infobash is run 
# from Konversation!

#################################################################################
################################  FUNCTIONS  ####################################
#################################################################################

# Infobash speaks through here. When run by Konversation, use DCOP
say () {
  if ((DEBUG)); then
    ((KONVI)) && dcop "$DCPORT" "$DCOPOBJ" say "$DCSERVER" "$DCTARGET" "konvi='$konvi'  saying : '$@'"\
    || echo "konvi='$konvi'  saying : '$@'"
  fi
  #((KONVI)) && dcop $DCPORT Konversation say $DCSERVER "$DCTARGET" "$1" || echo -ne "$1\n"
  ((KONVI)) && dcop "$DCPORT" "$DCOPOBJ" say "$DCSERVER" "$DCTARGET" "$1" || echo -ne "$1\n"
}

# Error handling
error () {
  case $1 in
    1) say "Infobash: Update failed!" ;;
    2) say "Infobash: Live execution failed, error $2!" ;;
    3) say "Infobash: Error in colorscheme, or unknown parameter: $2" ;;
    4) say "Infobash: Unknown verbosity level $2" ;;
    5) say "Infobash: Dependency not met: $2 not found in path" ;;
    6) say "Infobash: /proc not found! Quitting..." ;;
    *) say "Infobash: Error unknown: $@"
       set -- 99
  esac
  exit $1
}

eat () {
	gawk 'BEGIN { RS="" } { gsub(/\n$/,""); gsub(/\n/," "); printf $0 }' "$1"
}

# Determine if any of the absolutely necessary tools are absent 
checkdepend () {
  
  [[ -d /proc/ ]] || error 6

  if ((X)); then
    for I in xrandr xdpyinfo glxinfo; do
      type -p $I >/dev/null || { echo "Infobash: Resuming in non X mode: $I not found in path"; X=0; }
    done
  fi

  for I in gawk tr wget hostname lspci uname df wc free ps uptime grep; do
    type -p $I >/dev/null || error 5 "$I"
  done
}

# Filter boilerplate & buzzwords.
mkbans () {
  unset MKBANS
  # Iterate over $@
  for BANSTR; do
    #echo "BANSTR=\"$BANSTR\"" >&2
    if [[ ${BANSTR:0:1} = $'\2' ]]; then
      MKBANS="${MKBANS}${MKBANS+|}${BANSTR:1:${#BANSTR}-1}"
    else
      # Automatically escapes [ ] ( ) . and + 
      MKBANS="${MKBANS}${MKBANS+|}$(echo "$BANSTR" | gawk '{ gsub(/([\[\]+().])/,"\\\\&"); print }')"
    fi
  done
  echo "$MKBANS"
}

# Set the colorscheme 
# $1 = <scheme number>|<"none">
cscheme () {
  local I SCOLORS CLCODES
  [[ $1 = none ]] && { unset C1; unset C2; unset CN; }
  [[ $1 -ge ${#SCHEMES[@]} ]] && set -- 1 
  ((IBSHELL)) && CLCODES=($ANSICL) || CLCODES=($IRCCL)
  for ((I=0;I<${#COLORS[@]};I++)); do
    eval "${COLORS[I]}=\"${CLCODES[I]}\""
  done
  IFS="," ; SCOLORS=(${SCHEMES[$1]}) ; IFS="$OIFS"
  C1="${!SCOLORS[0]}"
  C2="${!SCOLORS[1]}"
  CN="${!SCOLORS[2]}"
  ((CSCHEME++))
}

# Parse the null separated commandline under /proc/<pid passed in $1>/cmdline
getcmdline () {
  [[ -e /proc/$1/cmdline ]] || { echo 0; return; }
  ##say "Marker"
  ##say "\$1='$1' -=- $(< /proc/$1/cmdline)"
  local I=0
  unset CMDL
  while read -d $'\0' L && [[ $I -lt 32 ]]; do 
    CMDL[I++]="$L"
  done </proc/$1/cmdline
  ##say "\$I='$I'"
  if ! ((I)); then
    CMDL[0]=$(< /proc/$1/cmdline)
    [[ -n ${CMDL[0]} ]] && I=1
  fi
  CMDLMAX=$I
}

# Determine where infobash was run from
roots () {
  if tty >/dev/null; then
    IRC="Shell"
    unset IRCV
    IBSHELL=1
  else
    if [[ -n $PPID && -f /proc/$PPID/exe ]]; then
      IRC=$(readlink /proc/$PPID/exe)
      # I've decided to make readlink(coreutils) a dependency.
      #IRC=$(ls -l /proc/$PPID/exe | gawk '{ sub(/.* -> /,"",$0; print }')
      ##say "\$IRC=\"$IRC\""
      case $(echo $IRC | tr [:upper:] [:lower:]) in
        *irssi-text*|*irssi*)	IRCV=" $($IRC -v | gawk 'NR == 1 { print $2 }')"
				IRC="Irssi" ;;
        *konversation*) 	KONVI=1
                       		IRCV="$($IRC -v | gawk '/Konversation:/ { for (i=2;i<=NF;i++) { if (i == NF) { print $i } else { printf $i" " } } exit }')"
				T=($IRCV)
				if [[ ${T[0]} == *+* ]]; then
					# < Sho_> locsmif: The version numbers of SVN versions look like this: 
					#         "<version number of last release>+ #<build number", i.e. "1.0+ #3177" ... 
					#         for releases we remove the + and build number, i.e. "1.0" or soon "1.0.1"
					IRCV=" CVS $IRCV"
					T2="${T[0]/+/}"
				else
					IRCV=" ${T[0]}"
					T2="${T[0]}"
				fi
				# Remove any dots except the first, and make sure there are no trailing zeroes, 
				T2=$(echo "$T2" | gawk '{ sub(/\./, " "); gsub(/\./, ""); sub(/ /, "."); printf("%g\n", $0) }')
				# Since Konversation 1.0, the DCOP interface has changed a bit: dcop "$DCPORT" Konversation ..etc
				# becomes : dcop "$DCPORT" default ... or dcop "$DCPORT" irc ..etc. So we check for versions smaller
				# than 1 and change the DCOP parameter/object accordingly.
				((`echo "${T2}<1" | bc`)) && DCOPOBJ="Konversation"
				IRC="Konversation" ;; 
        *xchat*)        	IRCV=" $($IRC -v | gawk 'NR == 1 { print $2 }')"
				IRC="X-Chat" ;;
	*bitchx*)	 	IRCV=" $($IRC -v | gawk '
				/Version/ { a=tolower($2); gsub(/[()]|bitchx-/,"",a); print a; exit }
				$2 == "version" { a=tolower($3); sub(/bitchx-/,"",a); print a; exit }
				')" 
				IRC="BitchX" ;;
	*ircii*)		IRCV=" $($IRC -v | gawk 'NR == 1 { print $3 }')"
				IRC="ircII" ;;		
	*gaim*)			IRCV=" $($IRC -v | gawk 'NR == 1 { print $2 }')"
				IRC="Gaim" ;;				
	*weechat-curses*)	IRCV=" $($IRC -v)" 
				IRC="Weechat" ;;			
	*perl*)			unset IRCV	# KSirc is one of the possibilities now. KSirc is a wrapper around dsirc, a perl client
				getcmdline $PPID
			        for ((I=0; I<=$CMDLMAX; I++)); do
                                  case ${CMDL[I]} in
                                    *dsirc*) IRC="KSirc"
				    	     # Dynamic runpath detection is too complex with KSirc, because KSirc is started from
					     # kdeinit. /proc/<pid of the grandparent of this process>/exe is a link to /usr/bin/kdeinit
					     # with one parameter which contains parameters separated by spaces(??), first param being KSirc.
					     # Then, KSirc runs dsirc as the perl irc script and wraps around it. When /exec is executed,
					     # dsirc is the program that runs infobash, therefore that is the parent process that we see.
					     # You can imagine how hosed I am if I try to make infobash find out dynamically with which path
					     # KSirc was run by browsing up the process tree in /proc. That alone is straightjacket material.
					     # (KSirc sucks anyway ;)
                                             IRCV=" $(ksirc -v | gawk '/KSirc:/ { print $2; exit }')"
					     break ;;
                                  esac
                                done 
				[[ -z $IRCV ]] && IRC="Unknown Perl client" ;;
	*bash*|*sh*)		unset IRCV
				getcmdline $PPID
				for ((I=0; I<=$CMDLMAX; I++)); do
				  case ${CMDL[I]} in
                                    *infobash*) IRC="Infobash Live" 
	                                        unset IRCV
						break ;;
				  esac 
				done
				[[ -z $IRCV ]] && IRC="Shell wrapper" ;;
	*)			IRC="Unknown : ${IRC##*/}" 
				unset IRCV
      esac
        [[ $SHOWIRC -lt 2 ]] && unset IRCV    
    else
      IRC="PPID=\"$PPID\" - empty?"
      unset IRCV
    fi
  fi
}

# Get the parameters
getparams () {
  [[ -z $1 ]] && return 1
  while [[ -n $1 ]]; do
    case $1 in
      --update)  
        TF="/tmp/tmp.$RANDOM"
        if wget -q -T$TIMEOUT -t1 -O"$TF" 'http://rebelhomicide.demon.nl/scripts/infobash'
        then
          if [[ -s $TF ]] # if exists and is not empty ... 
	  then 
	    cp -f "$TF" "$0" || error 1
	  else
	    error 1
	  fi
          say "Infobash: Updated to $(gawk '/^MYVERSION=/{print(gensub(/MYVERSION="[^ ]+ (.*)"/,"\\1","g",$0))}' $0)!"
        else
          error 1
        fi
        rm -f "$TF"
        exit 0 ;;
	
      --live) 
        shift  # get other options to pass to live infobash
        wget -q -T4 -t1 -O- 'http://rebelhomicide.demon.nl/scripts/infobash' | cat | bash -s $@ 
	    
# using cat was a trick solution to get the "broken pipe" error away from the wget exit code and into cat's exit code.
# another possibility :
# wget -O- 127.0.0.1/scripts/infobash 2> >(if grep -q 'Broken pipe'; then say "Found broken pipe" >&2; fi) | bash -s x
# a broken pipe occurs when the script is ended before the physical end of the scriptfile (example : if ...; then exit; fi), 
# which makes bash stop reading stdin because it is no longer needed. 
# however the left side of the pipe still wants to write...thus it errors, making my exit code detection code think
# the download failed, since wget only knows one error exit code, namely "1". :(

	PSTAT=(${PIPESTATUS[@]})
	[[ ${PSTAT[1]} -eq 0 && ${PSTAT[0]} -gt 0 ]] && error 2 "${PSTAT[@]}" 
	exit 0 ;;
	
      -v|-v[1-9]|--verbose) 
        if [[ ${#1} -eq 3 ]]; then
	  VBL="${1:2}"
	else
          if [[ $2 = --* || $2 = -* || -z $2 ]]; then
	    VBL=1
	  else
	    shift
	    VBL="$1" 
	  fi
	fi
	echo "$VBL" | grep -q '^[1-3]$' || error 4 "$VBL" ;;
      --crap)
        CRAP=1 ;;
      *)
        echo "$1" | grep -q '^[1-9][0-9]\?$' || error 3 "$1"
        ((CSCHEME)) || cscheme "$1"
    esac
  shift
  done    
}

# Enforce boilerplate and buzzword filters
sanitize () {
  #cannot use strong quotes to unquote a string with pipes in it! bash will interpret the |'s as usual and try to run a subshell!
  #using weak quotes instead, or use '"..."'
  echo "$2" | gawk "BEGIN { IGNORECASE=1 } { gsub(/${!1}/,\"\"); gsub(/ [ ]+/,\" \"); gsub(/^ +| +$/,\"\"); print }"
}

#################################################################################
##########################  CALCULATED VARIABLES  ###############################
#################################################################################

# Fallback paths put into $XPATH; This might, among others, help on gentoo.
# Now, create a difference of $PATH and $XPATH and add that to $PATH:
unset TPATH
IFS=":"
for I in $XPATH; do 
  FLAG=0
  for J in $PATH; do 
    [[ $I = $J ]] && FLAG=1
  done
  ((FLAG)) || TPATH="$TPATH:$I"
done
IFS="$OIFS"
PATH="${PATH}${TPATH}"
##echo "PATH='$PATH'" 
##/bin/sh -c 'echo "PATH in subshell=\"$PATH\""' 

# Check for dependencies before running any commands in this script! So yes, here!!
checkdepend

# Detect X and set variable "X" accordingly
[[ $DISPLAY ]] && X=1 

#PATH=$(echo -n "${XPATH}:${PATH}" | gawk ' 
#BEGIN { RS=":" } 
#{ h[$0] } 
#END { for (i in h) { if (f++) s=s":"i; else s=s i } print s }
#')
# Do this after sourcing of config overrides so user can customize banwords
NORMALBANS=$(mkbans "${NORMALBANS[@]}") # Contrary to my previous belief, "${ARR[@]}" passes a quoted list, not one string
CPUBANS=$(mkbans "${CPUBANS[@]}")
##echo "NORMALBANS='$NORMALBANS'"

LSPCI=$(lspci -v | awk '{ gsub(/\(prog-if[^)]*\)/,""); print }')
###################################################################################
#########################                              ############################
#########################          M  A  I  N          ############################
#########################                              ############################
###################################################################################

roots

if ((KONVI)); then
  DCPORT="$1"
  DCSERVER="$2"
  DCTARGET="$3"
  shift 3
  # The section below is on request of Argonel from the Konversation developer team:
  # it sources config files like $HOME/.kde/share/apps/konversation/scripts/infobash.conf
  IFS=":"; for I in $(kde-config --path data); do
    if [[ -r ${I}${KONVICFG} ]]; then source "${I}${KONVICFG}"; break; fi
  done
  IFS="$OIFS"
fi

getparams $@

# If no colorscheme was set in the parameter handling routine, then set the default scheme
((CSCHEME)) || cscheme "$DEFSCHEME"

HN=$(hostname)

unset DISTRO
ISSUE=$(eat /etc/issue)
ISSUE=$(echo $(gawk '{ gsub(/\\[a-zA-Z]/, ""); print }' /etc/issue))
##say "ISSUE='$ISSUE'"
case $(echo "$ISSUE" | tr [:upper:] [:lower:]) in
  *debian*)
    for I in /etc/kanotix-version /etc/knoppix-version; do
      [[ -s $I ]] && DISTRO=$(eat $I) && break
    done
    if [[ -z $DISTRO ]]; then 
      [[ -s /etc/debian_version ]] && DISTRO="Debian $(eat /etc/debian_version)" || DISTRO="Unknown Debian-based"
    fi
    ;; 
  *SuSE*)  DISTRO=$(gawk '/SuSE/ { printf $0; exit }' /etc/SuSE-release) ;;
  *turbolinux*) DISTRO="Turbolinux" ;;
  *slackware*) DISTRO="Slackware" ;;
  *redhat*) DISTRO="Redhat" ;;
  *ubuntu*) DISTRO="$ISSUE" ;;
  *) unset DISTRO 
  #$(gawk 'BEGIN { RS="" } { gsub(/\\[a-z]/,""); gsub(/ [ ]+/," "); gsub(/^ +| +$/,""); print }' /etc/issue);;
esac

##say "1:DISTRO='$DISTRO'"

if [[ -z $DISTRO ]]; then
  if [[ -f /etc/gentoo-release ]]; then
    DISTRO=$(eat /etc/gentoo-release)
  elif [[ -f /etc/mandrake-release ]]; then
    DISTRO=$(eat /etc/mandrake-release)
  elif [[ -f /etc/slackware-release ]]; then
    DISTRO="Slackware"
  elif [[ -f /etc/turbolinux-release ]]; then
    DISTRO="Turbolinux"
  elif [[ -f /etc/redhat-release ]]; then
    DISTRO="Redhat"
  elif [[ -f /etc/zenwalk-version ]]; then
    DISTRO=$(eat /etc/zenwalk-version)
  else DISTRO="Unknown distro o_O"
  fi
fi

##say "2:DISTRO='$DISTRO'" 

#for I in $DISTROS 
#do
#  [[ -f /etc/$I ]] && DISTRO=$(gawk 'BEGIN { RS="" } { gsub(/\\[a-z]/,""); gsub(/ [ ]+/," "); gsub(/^ +| +$/,""); print }' "/etc/$I")
#  [[ -n $DISTRO ]] && break 
#done
#: ${DISTRO=Unknown release o_O}

OSKERN=$(uname -a | gawk '{print $1,$3,$(NF-1)}')

IFS=$'\n'
CPU=($(gawk -F': ' '
# TAKE NOTE: \t+ will work for /proc/cpuinfo, but SOME ARBITRARY FILE used for TESTING might contain SPACES!
# Therefore PATCH to use [ \t]+ when TESTING!
/^processor\t+:/ { nr = $NF }

/^model name/ { cpu[nr, "model"] = $NF }

/^cpu MHz/    {
  if (!min) { min = $NF } else { if ($NF < min) { min = $NF } }
  if ($NF > max) { max = $NF }
  cpu[nr, "speed"] = $NF
}

/^cache size/      { cpu[nr, "cache"] = $NF }

/^flags/      { cpu[nr, "flags"] = $NF }

/^bogomips/   { cpu[nr, "bogomips"] = $NF }

END {
  #if (!nr) { print ",,,"; exit } # <- should this be necessary or should bash handle that
  for (i = 0; i <= nr; i++) {
    print cpu[i, "model"] "," cpu[i, "speed"] "," cpu[i, "cache"] "," cpu[i, "flags"] "," cpu[i, "bogomips"]
  }
  if (!min) { print "not found"; exit }
  if (min != max) { printf("Min:%s%s Max:%s%s\n",min,"Mhz",max,"Mhz") }
  else { printf("%s %s\n", max, "Mhz") }
}
' /proc/cpuinfo))
IFS="$OIFS"

for ((I=0;I<${#CPU[@]}-1;I++)); do
  IFS=","; CPUTMP=(${CPU[I]}); IFS="$OIFS"
  unset CPU[I]
  CPUTMP[0]=$(sanitize NORMALBANS "${CPUTMP[0]}")
  CPUTMP[0]=$(sanitize CPUBANS "${CPUTMP[0]}")
  # I use all these loops so I can easily extend the cpu array created in the awk script above with more fields per cpu.
  for ((J=0;J<${#CPUTMP[@]};J++)); do
    ((J)) && CPU[I]="${CPU[I]},${CPUTMP[J]}" || CPU[I]="${CPUTMP[J]}"
  done
done

if echo "${CPU[@]}" | grep -qi 'dual\|triple\|quad'; then
  NOCPUCOUNT=1
else
  case $((${#CPU[@]}-1)) in 
    2) CPU2="Dual";;
    3) CPU2="Triple";;
    4) CPU2="Quad";;
    [5-9]|[1-9][0-9]) CPU2="${#CPU[@]}x";;
    *) unset CPU2
  esac
fi

IFS=","; CPUTMP=(${CPU[0]}); IFS="$OIFS"
CPU2="${CPU2}${CPU2+ }${CPUTMP[0]}" # clocked at [${CPU[${#CPU[@]}-1]}]"
CPU3="${CPU[${#CPU[@]}-1]}"
CPU4="${CPUTMP[3]}"
unset CPUFLAGS
for I in $CPU4; do
  [[ $I == nx || $I == lm ]] && CPUFLAGS="${CPUFLAGS}${CPUFLAGS+ }$I"
done
[[ -z $CPUFLAGS ]] && CPUFLAGS="-"

#[[ VBL -ge 2 ]] && BOGO=$(gawk -F': ' '/bogomips/ { if ($2 > max) { max = $2 } } 
#END { printf("%s %s\n",max,"Bogomips") }' /proc/cpuinfo) || unset BOGO

#CACHE=$(gawk '/cache/{print $4$5; exit}' /proc/cpuinfo) 
#[[ -n $CACHE ]] && CPU2="$CPU2, $CACHE cache" 

for I in /proc/ide/ide*/hd*; do 
  if [[ -e $I/media && $(eat $I/media) = disk ]]; then
    if [[ ! -e $I/capacity ]]; then  # BUGFIX: Ran into a debian sarge kernel that did not have the "capacity" file in the hd* directories
      CAP=0
      break
    fi
    ((CAP+=$(eat $I/capacity)))
    HDDMOD="${HDDMOD}${HDDMOD+,}$(eat $I/model)"
  fi
done

if [[ -e /proc/scsi/scsi ]]; then
  # Silly sata detection, will also pick up usb sticks, and it is all I will put into infobash. if you want more, infoperl is on
  # the way :)
  IFS=$'\n'; THDD=($(gawk '
  BEGIN { IGNORECASE=1 }
  /host/ {
    getline a[$0]
    getline b[$0]
  }
  END {
    for (i in a) {
      if (b[i] ~ / *type: *direct-access.*/) {
        #c=gensub(/^ *vendor: (.+) +model: (.+) +rev: (.+)$/,"\\1 \\2 \\3","g",a[i])
        c=gensub(/^ *vendor: (.+) +model: (.+) +rev:.*$/,"\\1 \\2","g",a[i])
        gsub(/ [ ]+/, " ", c); gsub(/^ +| +$/, "", c)
        #print a[i]
        if (c ~ /\<flash\>|\<pendrive\>|memory stick|memory card/) continue
        print c
      }
    }
  }
  ' /proc/scsi/scsi)); IFS="$OIFS"

  for ((I=0;I<${#THDD[@]};I++)); do
    HDDMOD="${HDDMOD}${HDDMOD+,}${THDD[I]}"
  done
fi

##say "$HDDMOD" ; exit
((CAP)) && HDDCAP1="$((CAP/2))"
HDDCAP2=$(gawk '$2%16 == 0 {size+=$3} END {printf("%d\n",size)}' /proc/partitions)

##say "HDDCAP1=\"$HDDCAP1\"  HDDCAP2=\"$HDDCAP2"" ; exit
HDD=0 ; for I in ${!HDDCAP*}; do [[ ${!I} -gt $HDD ]] && HDD="${!I}" ; done 
if ((HDD)); then
  HDDUSG=$(df | gawk '$1 ~ /^\/dev\/[hs]d[a-z][0-9]+.*$/{count+=$3} END {printf("%d\n",count)}')
  HDDUSG="$((HDDUSG*100/HDD))%used"
  HDD="$(($HDD*1024/1000**3))GB"
else
  unset HDDUSG
  HDD="unknown.."
fi

MEM=$(free | gawk '/Mem:/ {printf("%s%s\n",$3/1024"/",$2/1024"MB")}')
PROC="$(($(ps aux | wc -l)-1))"
UPT=$(uptime | gawk '{a=gensub(/^.*up *([^,]*).*$/,"\\1","g",$0);gsub(/ /,"",a);print a}')
IFS=$'\n'; GFX=($(echo "$LSPCI" | gawk -F': ' '/VGA compatible controller/ { print $NF }')); IFS="$OIFS"
for ((I=0;I<${#GFX[@]};I++)); do GFX[I]=$(sanitize NORMALBANS "${GFX[I]}"); done
  
#GFXMEM="size=[$(echo "$LSPCI" | gawk '/VGA/{while (!/^$/) {getline;if (/size=[0-9][0-9]*M/) {size2=gensub(/.*\[size=([0-9]+)M\].*/,"\\1","g",$0);if (size<size2){size=size2}}}}END{print size2}')M]"
# GFXMEM is UNUSED at the moment, because it shows AGP aperture size, which is not necessarily equal to GFX memory..
if ((X)); then
  RES=$(xrandr | gawk '/\*/{print(gensub(/.* ([0-9]+) x ([0-9]+) .*/,"\\1x\\2","g",$0))}') 
  [[ -z $RES ]] && RES=$(xdpyinfo | gawk '/dimensions/ { print $2 }')
  # || RES=$(stty -a | gawk '/rows.*columns/{$a=gensub(/^.*rows ([0-9]+).*columns ([0-9]+).*$/,"\\2x\\1","g",$0);print $a}')
  FREQ=$(xrandr | gawk '/\*[0-9]+.* \*[0-9]+ .*/ { a=gensub(/\*[0-9]+.* \*([0-9]+) .*/,"\\1","g",$0); print a }')
  [[ -n $FREQ ]] && FREQ=" @${FREQ}hz"
 
  # X vendor and version detection.
  XVENDOR=$(xdpyinfo | gawk -F': +' '
  BEGIN { IGNORECASE=1 } 
  /vendor string/ { 
    gsub(/the|,|inc|foundation|project|coorperation/, "", $2)
    gsub(/^ +| +$/, "", $2); gsub(/  +/," ",$2)
    print $2
  } 
  ')
    
  # new method added since radeon and X.org and the disappearance of <X server name> version : ...etc 
  # Later on, the normal textual version string returned, e.g. like: X.Org version: 6.8.2
  # A failover mechanism is in place. (if $XVERNUM is empty, the release number is parsed instead)
  XVERNUM=$(xdpyinfo | awk '/version:/ { print $NF }')
  [[ -z $XVERNUM ]] && XVERNUM=$(xdpyinfo | gawk -F': +' 'BEGIN { IGNORECASE=1 } /vendor release number/ { gsub(/0+$/,"",$2); gsub(/0+/,".",$2); print $2 }')
  
  #X -version 2>&1 | gawk '/^X Window System Version/ { print $5 }'
  #This method could be used in the future to detect X when X is not running,
  #however currently infobash ignores X checks when X is not found.
  XVER="$XVENDOR $XVERNUM"
  
  IFS=$'\n'
  GLX=($(glxinfo | gawk -F ': ' '
  function join(arr, sep) {
    s=""; i=flag=0
    for (i in arr) {
      if (flag++) s=s sep; s=s i
    } 
    return s
  } 
  
  BEGIN { IGNORECASE=1 } 
  /opengl renderer/ { 
    if ($2 ~ /mesa/) { if ($2 ~ / r[3-9][0-9][0-9] /) { a[$2]; f++ } next }
    a[$2] 
  } 
  /opengl version/ && (f || $2 !~ /mesa/) { b[$2] } 
  /direct rendering/ { c[$2] } 
  END { printf("%s\n%s\n%s\n",join(a,", "),join(b,", "),join(c,", ")) }
  '))
  IFS="$OIFS"
  GLXR="${GLX[0]}"; GLXV="${GLX[1]}"; GLXDR="${GLX[2]}"
  
  # GLXR=$(glxinfo | gawk -F ': ' 'BEGIN {IGNORECASE=1} /opengl renderer/ && $2 !~ /mesa/ {seen[$2]++} END {for (i in seen) {printf("%s ",i)}}')
  #    GLXV=$(glxinfo | gawk -F ': ' 'BEGIN {IGNORECASE=1} /opengl version/ && $2 !~ /mesa/ {seen[$2]++} END {for (i in seen) {printf("%s ",i)}}')
     
  [[ -z $GLXR || -z $GLXV ]] && MESA=1
  AGPMOD=$(gawk '/agp/ && !/agpgart/ && $3 > 0 { print(gensub(/(.*)_agp.*/,"\\1","g",$1)) }' /proc/modules)
fi

if ((VBL)); then  # (IF VBL > 1)
  if ((SHOWHOST)) 
  then
    LNINTRO=$(printf "${C1}%-${INDENT}s${C2} \"%s\"${C1} %s " "Host/Kernel/OS" "$HN" "running") 
  else
    LNINTRO=$(printf "${C1}%-${INDENT}s${C2} " "OS/Kernel")
  fi
  LNINTRO="$LNINTRO$(echo -ne "${C2}$OSKERN ${CN}[ ${C1}$DISTRO ${CN}]")"
  say "$LNINTRO"

  ##say "CPU[0]=\"${CPU[0]}\""
  IFS=","; CPU4=(${CPU[0]}); IFS="$OIFS" 
  # Strange (and also some expected) behavior encountered.
  # If say() uses $1 as the parameter to output to the screen, then passing "<text1> ${ARR[@]} <text2>"
  # will output only <text1> and the first element of ARR. That "@" splits in elements and "*" _doesn't_, is to be expected.
  # However, that text2 is consecutively truncated is somewhat strange, so take note. This has been confirmed by #bash on freenode.
  # The above mentioned only emerges when using the debugging markers below
  ##say "CPU4=\"***${CPU4[@]} $HN+++++++\"----------"

  [[ -z ${CPU4[2]} ]] && CPU4[2]="unknown"
  
  [[ ${#CPU[@]} -gt 2 ]] && CPUTMP="(1)" || unset CPUTMP  # Array CPU always has one element: max clockfreq found. Therefore -gt and not -ge
  LNCPU=$(printf "${C1}%-${INDENT}s${C2} %s" "CPU Info" "${CPUTMP}${CPUTMP+ }${CPU4[0]}")
  [[ $VBL -ge 3 ]] && LNCPU=$(printf "%s${C2} %s %s ${C1}%s${CN}%s${C2} %s ${CN}%s" "$LNCPU" "${CPU4[2]}" "cache" "flags" "(" "$CPUFLAGS" ")")
  LNCPU=$(printf "%s ${C1}%s${C2} ${CN}%s${C2} %s ${CN}%s" "$LNCPU" "clocked at" "[" "${CPU4[1]} MHz" "]")
  say "$LNCPU"
  for ((I=1;I<${#CPU[@]}-1;I++)); do
    IFS=","; CPU4=(${CPU[I]}); IFS="$OIFS"
    LNCPU=$(printf "${C1}%-${INDENT}s${C2} %s" " " "($((I+1))) ${CPU4[0]}")
    [[ $VBL -ge 3 ]] && LNCPU=$(printf "%s${C2} %s %s ${C1}%s${CN}%s${C2} %s ${CN}%s" "$LNCPU" "${CPU4[2]}" "cache" "flags" "(" "$CPUFLAGS" ")")
    LNCPU=$(printf "%s ${C1}%s${C2} ${CN}%s${C2} %s ${CN}%s" "$LNCPU" "clocked at" "[" "${CPU4[1]} MHz" "]")
    say "$LNCPU"
    [[ $I -gt 10 ]] && break
  done


  LNGFX=$(printf "${C1}%-${INDENT}s${C2} %s" "Videocard" "${GFX[0]}")
  if ((X)); then
    LNGFX="$LNGFX$(echo -ne "${C1}  $XVER  ${CN}[${C2} ${RES}${FREQ} ${CN}]")"
  fi
  say "$LNGFX"
  I=1 ; while [[ -n ${GFX[I]} && $I -le 3 ]]; do
    LNGFX=$(printf "${C1}%-${INDENT}s${C2} %s" " " "${GFX[I]}")
    say "$LNGFX"
    ((I++))
  done

  if [[ $VBL -ge 2 ]]; then
    IFS=$'\n' LNNET=($(echo "$LSPCI" | gawk '
    BEGIN { IGNORECASE=1 }
    /^[0-9a-f:.]+ (ethernet|network) (controller|bridge)/ || /^[0-9a-f:.]+ [^:]+: .*(ethernet|network).*$/ {
      nic=gensub(/^[0-9a-f:.]+ [^:]+: (.+)$/,"\\1","g",$0)
      gsub(/realtek semiconductor/, "Realtek", nic)
      gsub(/davicom semiconductor/, "Davicom", nic)
      gsub(/,/," ", nic)
      gsub(/'"$NORMALBANS"'/, "", nic); gsub(/ [ ]+/," ", nic); gsub(/^ +| +$/,"", nic) 
      # The doublequotes above are necessary because of the pipes in the variable.
      eth[nic]++;
      while (getline && !/^$/) {
        if (/I\/O/) ports[nic]=ports[nic]$4" "
      }
    }
    END {
      j=0
      for (i in eth) {
        if (eth[i]>1) {
          a[j]=eth[i]"x "i;
          if (ports[i] != "") a[j]=a[j]", at ports: "ports[i];
        }
        else {
          a[j]=i
          if (ports[i] != "") a[j]=a[j]", at port: "ports[i];
        }
        j++;
      }
      j=0;
      while (a[j]) {
        print a[j]; 
        j++;
      }
    }
    '))
    IFS="$OIFS"

    if [[ -n ${LNNET[@]} ]]; then
      I=0
      say "$(printf "${C1}%-${INDENT}s${C2} %s" "Network cards" "${LNNET[I]}")"
      while [[ -n ${LNNET[++I]} ]]; do
        say "$(printf "${C1}%-${INDENT}s${C2} %s" " " "${LNNET[I]}")"
      done
    fi

  fi #if [[ $VBL -ge 2 ]]

  # Some code could look superfluous but BitchX doesn't like lines not ending in a newline. F*&k that bitch!
  LNLAST=$(echo -ne "${C1}Processes${C2} $PROC${CN} | ${C1}Uptime${C2} $UPT${CN} | ${C1}Memory${C2} $MEM${CN}")
  if [[ $VBL -ge 2 ]]; then
    LNLAST="$LNLAST$(echo -ne " | ${C1}HDD${C2} $HDDMOD ${C1}Size${C2} $HDD ($HDDUSG)${CN}")"
  else
    LNLAST="$LNLAST$(echo -ne " | ${C1}HDD Size${C2} $HDD ($HDDUSG)${CN}")" 
  fi
  
  if ((X)) && ! ((MESA)); then
    LNLAST="$LNLAST$(echo -ne " | ${C1}GLX Renderer${C2} $GLXR${CN} | ${C1}GLX Version${C2} $GLXV${CN}")"
    ((CRAP)) && LNLAST="$LNLAST$(echo -ne " | ${C1}Direct rendering${C2} $GLXDR${CN}")"
  fi
  ((SHOWIRC)) && LNLAST="$LNLAST$(echo -ne " | ${C1}Client${C2} $IRC$IRCV${CN}")"
  LNLAST="$LNLAST$(echo -ne " | ${C1}$MYVERSION${NORMAL}")"
  say "$LNLAST"
else # (IF VBL > 1 ... ELSE)
  #cscheme 12
  if ! ((IBSHELL)); then
    for I in $C1 $C2 $CN ; do case "$I" in "$GREEN"|"$WHITE"|"$YELLOW"|"$CYAN") BGBLACK=1 ;; esac ; done
    ((BGBLACK)) && { for I in C1 C2 CN ; do [[ "${!I}" = "$NORMAL" ]] && declare $I="${!I}15,1" || declare $I="${!I},1" ; done ; }
    #C1="${C1},1"; C2="${C2},1"; CN="${CN},1"
  fi
  LNSHORT=$(echo -ne "${C1}CPU${CN}[${C2}$CPU2 clocked at $CPU3${CN}]  ${C1}Kernel${CN}[${C2}$OSKERN${CN}]  ${C1}Up${CN}[${C2}${FL2}${FL1}$UPT${FL1}${CN}]  ${C1}Mem${CN}[${C2}${FL2}${FL1}${MEM}${FL1}${CN}]  ${C1}HDD${CN}[${C2}${FL2}${FL1}${HDD}($HDDUSG)${FL1}${CN}]  ${C1}Procs${CN}[${C2}${FL2}${FL1}${PROC}${FL1}${CN}]")
  ((SHOWIRC)) && LNSHORT="$LNSHORT$(echo -ne "  ${C1}Client${CN}[${C2}${IRC}${IRCV}${CN}]")"
  LNSHORT="$LNSHORT$(echo -ne "$NORMAL")"
  say "$LNSHORT"
fi # (IF VBL > 1)
((IBSHELL)) && echo -n "[0m"
exit 0  # weechat's executor plugin forced me to do this, and rightfully so, because else the exit code from the last command is taken..

